import os
import re
import json
import inquirer
from jira import JIRA
from bardapi import Bard


class Ticket:
    """
    A class used to represent a ticket.

    Attributes
    ----------
    bard_api_key : str
        API token for the Bard model provided by user.
    title : str
        User-provided title of the ticket.
    priority: str
        Ticket priority assigned by the user.
    ticket_body: str
        Final text of the ticket.

    Methods
    -------
    bard_model() -> Bard
        Returns an instance of the language model (Bard).

    clean_description(response: str) -> str
       Returns a cleaned response for describe section by removing unnecessary text generated by Bard.

    replace_alpha_numerals(response: str) -> str
       Returns a string made of a list where all alpha numerals are replaced by dashes "-"
    
    parser_sublists(input_string:str) -> dict
        Converts a list (in the form of a string) containing subpoints to a dictionary where the key is the title and the values are the descriptions.

    parser_no_sublists(input_string:str) -> dict
        Converts a list (in the form of a string) to a dictionary where the key is the title and the values are the descriptions.
    
    response_to_dict(self, response:str) -> dict: 
        Converts a string-formatted list into a dictionary by utilizing the functions parser_no_sublists() and parser_sublists().
        
    dict_to_str(text_dict: dict) -> str:
        Returns a numbered list from the content of the dict

    get_section_text(model:Bard, prompt:str) -> str: 
        Generates text from Bard based on a given prompt. 

    generate_response() -> dict
        Calls using get_section_text() to get all sections of the ticket, returning all text sections in a dictionary.

    create_ticket_body_text() -> str
        Calls generate_response() and concatenates the text sections into a single text.

    get_ticket_priority() -> None
        Provides the user with ticket priority options in the terminal and saves the response.

    upload_ticket_to_jira() -> None
        Creates and uploads the ticket in Jira
    """

    def __init__(self, bard_api_key: str, ticket_title: str):
        self.bard_api_key = bard_api_key
        self.title = ticket_title
        self.priority = None
        self.ticket_body = None

    def bard_model(self):
        """
        Returns an instance of the language model (Bard).
        """
        return Bard(token=self.bard_api_key)

    @staticmethod
    def clean_description(response: str) -> str:
        """
        Returns a cleaned response for describe section by removing unnecessary text generated by Bard.

        Parameters
        ----------
        response : str
            Text generated by Bard

        Returns
        -------
        cleaned_text: str
        """
        # remove text before 'Description'
        result = re.search(r"Description:(.*)", response)
        if result:
            cleaned_text = result.group(1).strip()
            return cleaned_text

        return ""

    @staticmethod
    def replace_alpha_numerals(response:str) ->str:
        """
        Returns a string made of a list where all alpha numerals are replaced by dashes "-"

        Parameters
        ----------
        response : str
            Text generated by Bard

        Returns
        -------
        cleaned_text: str
        """
        # Find all occurrences of alphabetic enumerations (a., b., c., etc.)
        matches = re.findall(r'(\b[a-zA-Z]\.\s)', response)

        # Replace each occurrence with '-'
        for match in matches:
            response = response.replace(match, '-')

        return response

    @staticmethod
    def parser_sublists(input_string:str) ->dict:
        """
        Converts a list (in the form of a string) containing subpoints to a dictionary where the key is the title and the values are the descriptions.

        Parameters
        ----------
        input_string : str            
            Input example: 
            1. Button Placement:
                - Prominence: The social media sharing button should be prominently displayed within the blog post section, ensuring visibility and accessibility to users.
            2. Supported Platforms:
                - Comprehensive Coverage: The button should support sharing on a wide range of popular social media platforms, including Facebook, Twitter, LinkedIn, and others.
                
        Returns
        -------
        parsed_dict: dict
            Dictionary representation of the input list
            For example: 
            {
                'Button Placement': ['Prominence: The social media sharing button should be prominently displayed within the blog post section, ensuring visibility and accessibility to users.'],
                'Supported Platforms': ['Comprehensive Coverage: The button should support sharing on a wide range of popular social media platforms, including Facebook, Twitter, LinkedIn, and others.']
            }
        """

        parsed_dict = {}
        current_key = None
        current_value = []

        lines = input_string.strip().split('\n')
        for line in lines:
            #find pattern number. title
            match = re.match(r'^(\d+)\. (.+?)$', line.strip())
            if match:
                if current_key is not None:
                    parsed_dict[current_key] = current_value
                current_key = match.group(2)
                current_value = []
            elif current_key is not None and line.strip() != '':
                # Subpoints found (remove leading hyphen)
                current_value.append(line.strip().lstrip('-').strip())

        # Adding the last section to the dictionary
        if current_key is not None:
            parsed_dict[current_key] = current_value

        return parsed_dict

    @staticmethod
    def parser_no_sublists(input_string:str) -> dict:
        """
        Converts a list (in the form of a string) containing no subpoints to a dictionary where the key is the title and the values are the descriptions.

        Parameters
        ----------
        input_string : str            
            Input example: 
            1. Button Placement: The social media sharing button should be prominently displayed within the blog post section, ensuring visibility and accessibility to users.
            2. Supported Platforms: The button should support sharing on a wide range of popular social media platforms, including Facebook, Twitter, LinkedIn, and others.

        Returns
        -------
        result_dict: dict
            Dictionary representation of the input list
            For example: 
            {
                'Button Placement': [The social media sharing button should be prominently displayed within the blog post section, ensuring visibility and accessibility to users.],
                'Supported Platforms': [The button should support sharing on a wide range of popular social media platforms, including Facebook, Twitter, LinkedIn, and others.]
            }
        """

        edited_text = input_string.replace('*', '')
        #find pattern number. title : description 
        pattern = re.compile(r'\s*(\d+)\.\s*([^:]+):\s*(.*)\s*,\s*')
        matches = pattern.findall(edited_text)

        result_dict = {}
        for match in matches:
            number, title, description = map(str.strip, match)
            result_dict[title] = [description]

        return result_dict

    def response_to_dict(self, response:str) -> dict: 
        """
        Converts a string-formatted list into a dictionary by utilizing the functions parser_no_sublists() and parser_sublists().

        Parameters
        ----------
        response : str     
            A string containing a list as part of the Bard response.

        Returns
        -------
        list_dict: dict
            Dictionary representation of the input list
        """
        #list enumerated with numerals are now enumerated with - 
        response_no_numerals = self.replace_alpha_numerals(response) 
        #for consistency removed the bold 
        response_no_bold = response_no_numerals.replace('*', '') 

        if '-' in response_no_bold: 
            list_dict = self.parser_sublists(response_no_bold)
        else: 
            list_dict = self.parser_no_sublists(response_no_bold)
        
        return list_dict
        

    @staticmethod
    def dict_to_str(text_dict: dict) -> str:
        """
        Returns a formatted text with sections and subpoints from the content of the dict.

        Parameters
        ----------
        text_dict : dict
            The dict that contains the response of Bard

        Returns
        -------
        formatted_text: str
            A formatted text with sections and subpoints
        """
        formatted_text = ""

        for num, (title, subpoints) in enumerate(text_dict.items(), start=1):
            formatted_text += f"{num}. **{title}**\n"
            for subpoint in subpoints:
                formatted_text += f"    - {subpoint}\n"

        # Remove trailing whitespaces
        formatted_text = formatted_text.rstrip()

        return formatted_text


    def get_section_text(self, model, prompt:str) -> str: 
        """
        Generates text from Bard based on a given prompt. 
        Continues generating responses until a valid dictionary can be extracted from Bard's output.
        
        Parameters
        ----------
        model : Bard
            Instance of Bard
        prompt: str 
            Prompt provided to Bard 

        Returns
        -------
        clean_section_text: str
        """
        bard_text = model.get_answer(prompt)["content"]
        print(bard_text)
        bard_dict = self.response_to_dict(bard_text)
        
        while bard_dict == {}:
            bard_text = model.get_answer(prompt)["content"]
            print(bard_text)
            bard_dict = self.response_to_dict(bard_text)
        
        clean_section_text = self.dict_to_str(bard_dict)
        return clean_section_text

    def generate_response(self) -> dict:
        """
        Uses the Bard model to generate all text sections of the ticket

        Parameters
        ----------
        None

        Returns
        -------
        text_section: dict
            Dictionary which contains the text sections of the ticket
        """
        
        print("Generating Ticket. Please wait...")

        # Prompt for description
        prompt_description = f"""
        Only provode a one-line description for the Jira Ticket titled '{self.title}'.

        Description in the following format: 'Description: We need to [TASK] from [RESOURCE] in order for [USER] to [ACTION]'.

        Examples:
        1. Description: We need a modal to assist users in renaming and describing a policy.
        2. Description: We want to establish distinct alarms for production and staging for 'cust-data-classifier' so that developers can identify the environment and respond to issues accordingly.
        """
        model = self.bard_model()

        description_text = model.get_answer(prompt_description)["content"]
        description_text_clean = self.clean_description(description_text)

        # Prompt for acceptance criteria
        prompt_acceptance_criteria = f"""Review the Jira Ticket titled '{self.title}' and provide a well-organized response in the form of a numbered list outlining the acceptance criteria. Emphasize the key goals and functionalities as indicated in the following description: '{description_text_clean}'.

        Ensure that your response adheres to the specified format with a short title and single line description:

        1. Button Placement: The social media sharing button should be prominently positioned within the blog post section, preferably near the post title or at the end of the post.
        2. Supported Platforms: The button must support sharing on popular social media platforms, including but not limited to Facebook, Twitter, and LinkedIn.
        3. Visual Design: The button's design should align with the overall aesthetics of the website. Implement hover effects to enhance the user experience.

        Response must adhere to this structure: number. short title: a single line description.
        """

        print("ac section ...")
        acceptance_criteria_text_clean = self.get_section_text(model, prompt_acceptance_criteria)

        # Prompt for subtasks
        prompt_subtasks = f"""Given the Jira Ticket titled '{self.title}', its description {description_text_clean} and acceptance criteria {acceptance_criteria_text_clean}, 
        return a dictionary comprising a concise list of independent subtasks to complete the ticket. 
        Each subtask must be self-contained and mutually exclusive.

       Ensure that your response adheres to the specified format with a short title and single line description:

            1. Implementation of Button Component: Create a reusable component for the social media sharing button.,
            2. Integration with Social Media APIs: Integrate the button with the APIs of selected social media platforms for sharing functionality.,
            3. Styling and Responsiveness: Apply consistent styling to the button and ensure it looks good on all devices.
        
        Response must adhere to this structure: number. short title: a single line description.

        """
        print("st section ...")
        subtasks_text_clean = self.get_section_text(model, prompt_subtasks)

    
        # Prompt for assumptions
        prompt_assumptions = f"""Given the Jira Ticket titled '{self.title}', its description {description_text_clean} and acceptance criteria {acceptance_criteria_text_clean}, and with subtasks '{subtasks_text_clean}' 
        return a dictionary comprising a concise list of the assumptions. 

        Ensure that your response adheres to the specified format with a short title and single line description:

            1. Backend Support: It is assumed that the backend infrastructure already supports generating shareable links for blog posts,
            2. API Availability: The availability and stability of the social media platform APIs are assumed for the sharing functionality,
            3. Design Assets: Necessary design assets, such as icons for social media platforms, are assumed to be available for implementation
        
        Response must adhere to this structure: number. short title: a single line description.
        """
        print("as section ...")
        assumptions_text_clean = self.get_section_text(model, prompt_assumptions)


        text_section = {
            "description": description_text_clean,
            "acceptance_criteria": acceptance_criteria_text_clean,
            "subtasks": subtasks_text_clean,
            "assumptions": assumptions_text_clean,
        }

        return text_section

    # def generate_response(self) -> dict:
    #     """
    #     Uses the Bard model to generate all text sections of the ticket

    #     Parameters
    #     ----------
    #     None

    #     Returns
    #     -------
    #     text_section: dict
    #         Dictionary which contains the text sections of the ticket
    #     """
        
    #     print("Generating Ticket. Please wait...")

    #     # Prompt for description
    #     prompt_description = f"""
    #     Only provode a one-line description for the Jira Ticket titled '{self.title}'.

    #     Description in the following format: 'Description: We need to [TASK] from [RESOURCE] in order for [USER] to [ACTION]'.

    #     Examples:
    #     1. Description: We need a modal to assist users in renaming and describing a policy.
    #     2. Description: We want to establish distinct alarms for production and staging for 'cust-data-classifier' so that developers can identify the environment and respond to issues accordingly.
    #     """
    #     model = self.bard_model()

    #     description_text = model.get_answer(prompt_description)["content"]
    #     description_text_clean = self.clean_description(description_text)

    #     # Prompt for acceptance criteria
    #     prompt_acceptance_criteria = f"""Given the Jira Ticket titled '{self.title}', provide a structured response in the form of a dictionary containing the acceptance criteria. 
    #     Emphasize the goals and functionality outlined in the following description: '{description_text_clean}'.

    #     The return must be a single dictionary where the key is a short title and the value is a single line description, following the format illustrated below:
    #     ```python
    #     dict ={{
    #         Button Placement: The social media sharing button should be prominently placed within the blog post section, preferably near the post title or at the end of the post.,
    #         Supported Platforms: The button should support sharing on popular social media platforms, including but not limited to Facebook, Twitter, and LinkedIn.,
    #         Visual Design: The button's design should be consistent with the overall aesthetics of the website. Hover effects should be implemented for a better user experience.
    #     }}
    #     ```
    #     """
    #     print("ac section ...")
    #     acceptance_criteria_text_clean = self.get_section_text(prompt_acceptance_criteria)

    #     # Prompt for subtasks
    #     prompt_subtasks = f"""Given the Jira Ticket titled '{self.title}', its description {description_text_clean} and acceptance criteria {acceptance_criteria_text_clean}, 
    #     return a dictionary comprising a concise list of independent subtasks to complete the ticket. 
    #     Each subtask must be self-contained and mutually exclusive.

    #     The return must be a single dictionary where the key is a short title and the value is a single line description, following the format as example below:
    #     ```python
    #     dict ={{
    #         Implementation of Button Component: Create a reusable component for the social media sharing button.,
    #         Integration with Social Media APIs: Integrate the button with the APIs of selected social media platforms for sharing functionality.,
    #         Styling and Responsiveness: Apply consistent styling to the button and ensure it looks good on all devices.
    #     }}
    #     ```
    #     """
    #     print("st section ...")
    #     subtasks_text_clean = self.get_section_text(prompt_subtasks)

    
    #     # Prompt for assumptions
    #     prompt_assumptions = f"""Given the Jira Ticket titled '{self.title}', its description {description_text_clean} and acceptance criteria {acceptance_criteria_text_clean}, and with subtasks '{subtasks_text_clean}' 
    #     return a dictionary comprising a concise list of the assumptions. 

    #     The return must be a single dictionary where the key is a short title and the value is a single line description, following the example below:
    #     ```python
    #     dict = {{
    #         Backend Support: It is assumed that the backend infrastructure already supports generating shareable links for blog posts,
    #         API Availability: The availability and stability of the social media platform APIs are assumed for the sharing functionality,
    #         Design Assets: Necessary design assets, such as icons for social media platforms, are assumed to be available for implementation
    #     }}
    #     ```
    #     """
    #     print("as section ...")
    #     assumptions_text_clean = self.get_section_text(prompt_assumptions)


    #     text_section = {
    #         "description": description_text_clean,
    #         "acceptance_criteria": acceptance_criteria_text_clean,
    #         "subtasks": subtasks_text_clean,
    #         "assumptions": assumptions_text_clean,
    #     }

    #     return text_section

    def create_ticket_body_text(self) -> None:
        """
        Calls generate_response() and concatenates the text sections which is saved as the attribute ticket_body.

        Parameters
        ----------
        None

        Returns
        -------
        None
        """

        # get the text sections for the ticket
        ticket_text_sections = self.generate_response()

        self.ticket_body = f"""

            h2. Task Scope:
            {{panel:bgColor=#deebff}}
            {ticket_text_sections['description']}
            {{panel}}

            h2. Importance/Urgancy:
            {{panel:bgColor=#fefae6}}
            {'Priority: ' + self.priority}
            {{panel}}

            h2. Acceptance Criteria:
            {ticket_text_sections['acceptance_criteria']}

            h2. Sub-tasks:
            {ticket_text_sections['subtasks']}

            h2. Assumptions: 
            {ticket_text_sections['assumptions']}

            """

    def get_ticket_prority(self) -> None:
        """
        Provides the user with ticket priority options in the terminal, and saves the user response as the attribute priority

        Parameters
        ----------
        None

        Returns
        -------
        None
        """

        questions = [
            inquirer.List(
                "priority",
                message="Assign a priority to the ticket",
                choices=["Highest", "High", "Medium", "Low", "Lowest"],
            ),
        ]
        answers = inquirer.prompt(questions)
        self.priority = answers["priority"]

    def upload_ticket_to_jira(self, jira_credentials: dict) -> None:
        """
        Create a new ticket in Jira with the content generated by Bard.

        Parameters
        ----------
        jira_credentials: dict
            A dictionary containing the credentials needed to connect with Jira.
            - server (str): The Jira server URL.
            - email_address (str): User's email address for authentication.
            - token (str): Authentication token for accessing Jira.
            - key (str): Project key for identifying the project in Jira.

        Returns
        -------
        None
        """

        # Connect to Jira using provided credentials
        jira = JIRA(
            options={"server": jira_credentials["server"]},
            basic_auth=(jira_credentials["email_address"], jira_credentials["token"]),
        )

        # Prepare issue data
        issue_dict = {
            "project": {"key": jira_credentials["key"]},
            "summary": f"{self.title}",
            "description": f"{self.ticket_body}",
            "priority": {"name": f"{self.priority}"},
            "issuetype": {"name": "Task"},
        }

        try:
            # Create a new issue in Jira
            jira.create_issue(fields=issue_dict)
            print("The following ticket was successfully created and uploaded to Jira:")
            print(f"{self.ticket_body}")
        except Exception as e:
            # Handle any exceptions that may occur during the Jira issue creation
            print(f"Failed to create Jira issue. Error: {str(e)}")


def get_bard_api_key() -> str:
    """
    Get the api tokens for the LLM model (Bard).

    Parameters
    ----------
    None

    Returns
    -------
    api_token_dict: str
    """

    file_path = os.getenv("BARD_API_TOKEN_FILE")

    try:
        with open(file_path, "r") as file:
            api_token = json.load(file)

        return api_token["api_token"]

    except Exception as e:
        print(f"Error reading API token file: {e}")
        raise RuntimeError("Failed to read API token file")


def get_jira_credentials() -> dict:
    """
    Get credentials for Jira.

    Parameters
    ----------
    None

    Returns
    -------
    jira_credentials: dict
        A dictionary containing the credentials needed to connect with Jira.
        - server (str): The Jira server URL.
        - email_address (str): User's email address for authentication.
        - token (str): Authentication token for accessing Jira.
        - key (str): Project key for identifying the project in Jira.
    """

    file_path = os.getenv("JIRA_CREDENTIALS_FILE")

    try:
        with open(file_path, "r") as file:
            credentials = json.load(file)
        return credentials

    except Exception as e:
        print(f"Error reading jira credentials: {e}")
        raise RuntimeError("Failed to read jira credentials")


def get_ticket_title() -> str:
    """
    Prompts the user to enter a title for a ticket and checks its validity before returning.

    Parameters
    ----------
    None

    Returns
    -------
    ticket_title: str
        User provided title of the ticket
    """

    # Get ticket title from the user
    ticket_title = input("Enter the title of the ticket: ")
    words_in_title = ticket_title.split()

    # error handling of provided title
    if len(words_in_title) == 1:
        print(
            "The title provided contains only a single word. \nTo improve final ticket quality provide a more descriptive title."
        )
        ticket_title = input("Enter improved ticket title: ")
    elif bool(re.match(r"^\d+$", ticket_title)):
        print(
            "Invalid input, unable to create ticket from a title which only contains digits."
        )
        ticket_title = input("Enter improved ticket title: ")

    return ticket_title


if __name__ == "__main__":
    # get Bard and Jira credentials
    jira_credentials = get_jira_credentials()
    bard_api_key = get_bard_api_key()

    # Get ticket title from the user
    ticket_title = get_ticket_title()

    # generate ticket
    ticket = Ticket(bard_api_key, ticket_title.title())
    ticket.get_ticket_prority()
    ticket.create_ticket_body_text()
    ticket.upload_ticket_to_jira(jira_credentials)
