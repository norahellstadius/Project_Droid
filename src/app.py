import os
import re
import json
import inquirer
from jira import JIRA
from bardapi import Bard


class Ticket:
    """
    A class used to represent a ticket.

    Attributes
    ----------
    bard_api_key : str
        API token for the Bard model.
    title : str
        User-provided title of the ticket.
    priority: str
        Ticket priority assigned by the user.
    ticket_body: str
        Final text of the ticket.

    Methods
    -------
    bard_model() -> Bard
        Returns an instance of the language model (Bard).

    clean_text(response: str, is_list: bool = False) -> str
        Returns a cleaned response, removing unnecessary text generated by Bard.

    iterative_refinement(text: str, type: str) -> str
        Uses a previously generated Bard text as a prompt to Bard and returns a refined text.
    
    post_process(text: str, type:str) -> str
        Calls clean_text and iterative_refinement to return a refined text section

    generate_response() -> dict
        Uses the Bard model to generate the text section of the ticket, returning sections in a dictionary.

    create_ticket_body_text() -> str
        Calls generate_response() and concatenates the text sections.

    get_ticket_priority() -> None
        Provides the user with ticket priority options in the terminal.

    upload_ticket_to_jira() -> None
        Create a new ticket in Jira
    """

    def __init__(self, bard_api_key: str, ticket_title: str):
        self.bard_api_key = bard_api_key
        self.title = ticket_title
        self.priority = None
        self.ticket_body = None

    def bard_model(self):
        """
        Returns an instance of the language model (Bard).
        """
        return Bard(token=self.bard_api_key)

    @staticmethod
    def clean_text(response: str, is_list=False) -> str:
        """
        Returns a cleaned response, removing unnecessary text generated by Bard.

        Parameters
        ----------
        response : str
            The text generated by Bard
        is_list : str, optional
            Bool indicating if the final output is a list. 
            Every section is of type list except for 'description'

        Returns
        -------
        cleaned_text: str
        """
        if is_list:
            # remove any text before the list 
            pattern = re.compile(r"\*?\d+\.\s.*", re.DOTALL)
            matches = pattern.findall(response)
            new_response = "\n".join(matches)

            # in Jira bold text is with a single *
            cleaned_text = re.sub(r"\*\*", "*", new_response)
            return cleaned_text
        else:
            #remove text before 'Description' 
            result = re.search(r"Description:(.*)", response)
            if result:
                cleaned_text = result.group(1).strip()
                return cleaned_text

    def iterative_refinement(self, text:str, type: str) -> str:
        """
        Uses a previously generated Bard text as a prompt to Bard and returns a refined text

        Parameters
        ----------
        text : str
            The text generated by Bard
        type : str
            The section which the text represents (options: 'acceptance_criteria' and 'subtasks')

        Returns
        -------
        cleaned_text: str
        """
        model = self.bard_model()

        if type == "acceptance_criteria":
            example = """
                    1. The exit button should be *clearly visible and easily accessible* to users at all times.
                    2. Clicking the exit button should *immediately close* the payment website without any errors or prompts.
                    3. Clicking the exit button *should not interfere* with the user's ability to complete the payment process.
                """
        elif type == "subtasks":
            example = """
                    1. *Design Implementation:* 
                        - Collaborate with the design team to implement the visual aspects of the multilevel navigation.
                    2. *Backend Integration:* 
                        - Update the backend to support the new navigation structure.
                    3. *Frontend Development:* 
                        - Implement the frontend components for the multilevel navigation.
                    4. *Testing and QA:* 
                        - Conduct unit testing for each component.
                    5. *Documentation:* 
                        - Update relevant documentation to reflect the changes made to the navigation system.
                """
        else:
            raise ValueError(
                f"Invalid type: {type}. Please use 'acceptance_criteria' or 'subtasks'."
            )
        
        prompt = f"""Ensure the the Jira ticket {type} section given by {text} followings the same short, clear and concise structure as the example:\n{example}"""
        response = model.get_answer(prompt)["content"]
        clean_text = self.clean_text(response, True) #ensure only the list is included 
        return clean_text

    def post_process(self, text:str, type: str) -> str:
        """
        Calls clean_text and iterative_refinement to return a post processed text section

        Parameters
        ----------
        text : str
            The text generated by Bard
        type : str
            The section which the text represents (options: 'description', 'acceptance_criteria', 'subtasks' or 'assumptions')

        Returns
        -------
        pp_text: str
        """
        if type == "description":
            pp_text = self.clean_text(text)
            return pp_text
        elif type == "acceptance_criteria":
            parsed_text = self.clean_text(text, True)
            pp_text = self.iterative_refinement(parsed_text, type)
        elif type == "subtasks":
            parsed_text = self.clean_text(text, True)
            pp_text = self.iterative_refinement(parsed_text, type)
        elif type == "assumptions":
            pp_text = self.clean_text(text, True)
        else:
            raise ValueError(
                f"Invalid type: {type}. Please use 'description', 'acceptance_criteria', 'subtasks' or 'assumptions'."
            )

        return pp_text

    def generate_response(self) -> dict:
        """
        Uses the Bard model to generate the text sections of the ticket

        Parameters
        ----------
        None

        Returns
        -------
        text_section: dict
            Dictionary which contains the text sections of the ticket
        """
        print("Generating Ticket. Please wait...")
        model = self.bard_model()

        # Prompt for one-line description
        prompt_description = f"""
        Only provode a one-line description for the Jira Ticket titled '{self.title}'.

        Description in the following format: 'Description: We need to [TASK] from [RESOURCE] in order for [USER] to [ACTION]'.

        Examples:
        1. Description: We need a modal to assist users in renaming and describing a policy.
        2. Description: We want to establish distinct alarms for production and staging for 'cust-data-classifier' so that developers can identify the environment and respond to issues accordingly.
        """

        description_text = model.get_answer(prompt_description)["content"]
        description_text_clean = self.post_process(description_text, "description")


        # Prompt for acceptance criteria
        prompt_ac = f"""Solely provide acceptance criteria in the form of a short numbered list for the Jira Ticket titled '{self.title}' 
                        and described as '{description_text}'.
                        Acceptance criteria should focus on goals & functionality
                        
                        An example: 
                        1. The exit button should be *clearly visible and easily accessible* to users at all times.
                        2. Clicking the exit button should *immediately close* the payment website without any errors or prompts.
                        3. Clicking the exit button *should not interfere* with the user's ability to complete the payment process.
                        """
        ac_text = model.get_answer(prompt_ac)["content"]
        ac_text_clean = self.post_process(ac_text, "acceptance_criteria")

        # Prompt for subtasks
        prompt_subtasks = f"""Generate a concise numbered list of independent tasks needed to complete Ticket titled '{self.title} and with the acceptance criteria {ac_text_clean}. 
                            Ensure that each subtask is self-contained and mutally exclusive, meaning it could function as a separate Jira ticket.
                            
                            An example: 
                            1. *Design Implementation:* 
                                - Collaborate with the design team to implement the visual aspects of the multilevel navigation.
                            2. *Backend Integration:* 
                                - Update the backend to support the new navigation structure.
                            3. *Frontend Development:* 
                                - Implement the frontend components for the multilevel navigation.
                            4. *Testing and QA:* 
                                - Conduct unit testing for each component.
                            5. *Documentation:* 
                                - Update relevant documentation to reflect the changes made to the navigation system.
                            
                            Provide both a bolded title (the first line) and a short description (the following bullet point) for each task.
                            """
        subtasks_text = model.get_answer(prompt_subtasks)["content"]
        subtasks_text_clean = self.post_process(subtasks_text, "subtasks")

        # Prompt for assumptions
        prompt_assumptions = f"""Provide a very short numbered list of assumptions for the Jira Ticket titled '{self.title}', 
                                described as '{description_text_clean}', with acceptance criteria '{ac_text_clean}' 
                                and with sub tasks '{subtasks_text_clean}'."""
        assumptions_text = model.get_answer(prompt_assumptions)["content"]
        assumptions_text_clean = self.post_process(assumptions_text, "assumptions")

        text_section = {
            "description": description_text_clean,
            "acceptance_criteria": ac_text_clean,
            "subtasks": subtasks_text_clean,
            "assumptions": assumptions_text_clean,
        }

        return text_section

    def create_ticket_body_text(self) -> None:
        """
        Calls generate_response() and concatenates the text sections which is saved as an attribute.
        """

        # get the text sections for the ticket
        ticket_text_sections = self.generate_response()

        self.ticket_body = f"""

            h2. Task Scope:
            {{panel:bgColor=#deebff}}
            {ticket_text_sections['description']}
            {{panel}}

            h2. Importance/Urgancy:
            {{panel:bgColor=#fefae6}}
            {'Priority: ' + self.priority}
            {{panel}}

            h2. Acceptance Criteria:
            {ticket_text_sections['acceptance_criteria']}

            h2. Sub-tasks:
            {ticket_text_sections['subtasks']}

            h2. Assumptions: 
            {ticket_text_sections['assumptions']}

            """

    def get_ticket_prority(self) -> None:
        """
        Provides the user with ticket priority options in the terminal, and saves the user response as an attribute
        """

        questions = [
            inquirer.List(
                "priority",
                message="Assign a priority to the ticket",
                choices=["Highest", "High", "Medium", "Low", "Lowest"],
            ),
        ]
        answers = inquirer.prompt(questions)
        self.priority = answers["priority"]

    def upload_ticket_to_jira(self, jira_credentials: dict) -> None:
        """
        Create a new ticket in Jira with the content generated by Bard.

        Parameters
        ----------
        jira_credentials: dict
            A dictionary containing the credentials needed to connect with Jira.
            - server (str): The Jira server URL.
            - email_address (str): User's email address for authentication.
            - token (str): Authentication token for accessing Jira.
            - key (str): Project key for identifying the project in Jira.

        Returns
        -------
        None
        """

        # Connect to Jira using provided credentials
        jira = JIRA(
            options={"server": jira_credentials["server"]},
            basic_auth=(jira_credentials["email_address"], jira_credentials["token"]),
        )

        # Prepare issue data
        issue_dict = {
            "project": {"key": jira_credentials["key"]},
            "summary": f"{self.title}",
            "description": f"{self.ticket_body}",
            "priority": {"name": f"{self.priority}"},
            "issuetype": {"name": "Task"},
        }

        try:
            # Create a new issue in Jira
            jira.create_issue(fields=issue_dict)
            print("The following ticket was successfully created and uploaded to Jira:")
            print(f"{self.ticket_body}")
        except Exception as e:
            # Handle any exceptions that may occur during the Jira issue creation
            print(f"Failed to create Jira issue. Error: {str(e)}")


def get_bard_api_key() -> str:
    """
    Get the api tokens for the LLM model (Bard).

    Parameters
    ----------
    None

    Returns
    -------
    api_token_dict: str
    """

    file_path = os.getenv("BARD_API_TOKEN_FILE")

    try:
        with open(file_path, "r") as file:
            api_token = json.load(file)

        return api_token["api_token"]

    except Exception as e:
        print(f"Error reading API token file: {e}")
        raise RuntimeError("Failed to read API token file")


def get_jira_credentials() -> dict:
    """
    Get credentials for Jira.

    Parameters
    ----------
    None

    Returns
    -------
    jira_credentials: dict
        A dictionary containing the credentials needed to connect with Jira.
        - server (str): The Jira server URL.
        - email_address (str): User's email address for authentication.
        - token (str): Authentication token for accessing Jira.
        - key (str): Project key for identifying the project in Jira.
    """

    file_path = os.getenv("JIRA_CREDENTIALS_FILE")

    try:
        with open(file_path, "r") as file:
            credentials = json.load(file)
        return credentials

    except Exception as e:
        print(f"Error reading jira credentials: {e}")
        raise RuntimeError("Failed to read jira credentials")


if __name__ == "__main__":

    # get Bard and Jira credentials
    jira_credentials = get_jira_credentials()
    bard_api_key = get_bard_api_key()

    # Get ticket title from the user
    ticket_title = input("Enter the title of the ticket: ")
    words_in_title = ticket_title.split()

    # error handling of provided title
    if len(words_in_title) == 1:
        print(
            "The title provided contains only a single word. \nTo improve final ticket quality provide a more descriptive title."
        )
        ticket_title = input("Enter improved ticket title: ")
    elif bool(re.match(r"^\d+$", ticket_title)):
        print(
            "Invalid input, unable to create ticket from a title which only contains digits."
        )
        ticket_title = input("Enter improved ticket title: ")

    # generate ticket
    ticket = Ticket(bard_api_key, ticket_title.title())
    ticket.get_ticket_prority()
    ticket.create_ticket_body_text()
    ticket.upload_ticket_to_jira(jira_credentials)
